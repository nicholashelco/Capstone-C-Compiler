
%{

%}


 /* I used this page as a reference for precedence:               */
 /* https://en.cppreference.com/w/c/language/operator_precedence  */


 /* No Precedence necessary */
%token L_BRACE
%token R_BRACE
%token SEMICOLON

%token IF
%token ELSE
%token FOR
%token DO
%token WHILE
%token RETURN
%token BREAK
%token CONTINUE

%token SHORT_TYPE
%token INT_TYPE
%token LONG_TYPE
%token UNSIGNED_TYPE
%token FLOAT_TYPE
%token DOUBLE_TYPE
%token CHAR_TYPE
%token STRUCT_TYPE
%token ENUM_TYPE
%token UNION_TYPE
%token VOID_TYPE

%token ID
%token LIT_NUM
%token LIT_CHAR
%token LIT_STRING


 /* Level 15 Precedence */
%token COMMA


 /* Level 14 Precedence */
%token AND_ASSN   OR_ASSN     XOR_ASSN
%token MULTI_ASSN DIVIDE_ASSN MODULO_ASSN
%token ADD_ASSN   MINUS_ASSN
%token ASSN


 /* Level 13 Precedence */
 /* TERNARY */
%token COLON
%token QUESTION


 /* Level 12 Precedence */
%token LOGICAL_OR


 /* Level 11 Precedence */
%token LOGICAL_AND


 /* Level 10 Precedence */
%token BITWISE_OR


 /* Level 9 Precedence */
%token BITWISE_XOR


 /* Level 8 Precedence */
 /* bitwise AND */


 /* Level 7 Precedence */
%token EQUAL_COMP NOT_EQUAL_COMP


 /* Level 6 Precedence */
%token GREATER_THAN_COMP GREATER_THAN_EQUAL_COMP
%token LESS_THAN_COMP    LESS_THAN_EQUAL_COMP


 /* Level 5 Precedence */
%token BITWISE_LSHIFT BITWISE_RSHIFT


 /* Level 4 Precedence */
%left PLUS MINUS


 /* Level 3 Precedence */
%left ASTERISK DIVIDE MODULO


 /* Level 2 Precedence */
 /* Sizeof */
%token    AMP
 /* DEREFERENCE */
 /* TYPE CAST */
%token    LOGICAL_NOT BITWISE_NOT
%nonassoc U_MINUS


 /* Level 1 Precedence */
%token DOT
%token L_BRACKET R_BRACKET
%token L_PAREN   R_PAREN
%right INCREMENT DECREMENT



%%


 /* Expressions, Terms, Factors */
expr   : LIT_NUM                   {}
       | LIT_CHAR                  {}
       | ID                        {}
       | expr PLUS expr            {}
       | expr MINUS expr           {}
       | expr ASTERISK expr        {}
       | expr DIVIDE expr          {}
       | expr MODULO expr          {}
       | MINUS expr %prec U_MINUS  {}
       | L_PAREN expr R_PAREN      {}
       ;


 /* if statements */
ifStmt          : matched_ifStmt {}
                | open_ifStmt    {}
                ;

matched_ifStmt  : if L_PAREN expr R_PAREN L_BRACE matched_ifStmt R_BRACE else L_BRACE matched_ifStmt R_BRACE {}
                ;

open_ifStmt     : if L_PAREN expr R_PAREN L_BRACE ifStmt R_BRACE {}
                | if L_PAREN expr R_PAREN L_BRACE matched_ifStmt R_BRACE else L_BRACE open_ifStmt R_BRACE    {}


 /* while loops */


 /* for loops */