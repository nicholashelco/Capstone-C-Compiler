/* ================================== */
/* Definitions Section */


/* Code in %{ %} blocks are copied verbatim to output code */
%{

/* Header file generated by bison */
#include "TokenNames.tab.h"

%}

/* Regular Definitions here */
dlim    [ \t\n]
ws      {dlim}+
letter  [A-Za-z]
digit   [0-9]
id      (_|{letter})({letter}|{digit}|_)*



%%



 /* ================================== */
 // Rules Section */

 /* Consume whitespace */
{ws}+  { /* do nothing */ }

 /* Keywords */
if        return(IF);
else      return(ELSE);
for       return(FOR);
do        return(DO);
while     return(WHILE);
return    return(RETURN);
break     return(BREAK);
continue  return(CONTINUE);

short     return(SHORT_TYPE);
int       return(INT_TYPE);
long      return(LONG_TYPE);
unsigned  return(UNSIGNED_TYPE);
float     return(FLOAT_TYPE);
double    return(DOUBLE_TYPE);
char      return(CHAR_TYPE);
struct    return(STRUCT_TYPE);
enum      return(ENUM_TYPE);
union     return(UNION_TYPE);
void      return(VOID_TYPE);





 /* identifiers */
{id}  {yylval = installID(); return(IDEN); }

 /* parentheses, braces, brackets, punctuation */
"("   return(L_PAREN);
")"   return(R_PAREN);
"["   return(L_BRACKET);
"]"   return(R_BRACKET);
"{"   return(L_BRACE);
"}"   return(R_BRACE);
","   return(COMMA);
"."   return(DOT);
";"   return(SEMICOLON);
":"   return(COLON);
"?"   return(QUESTION);

 /* arithmetic operators */
"+"   return(PLUS);
"-"   return(MINUS);
"*"   return(ASTERISK);
"/"   return(DIVIDE);
"%"   return(MODULO);
"++"  return(INCREMENT);
"--"  return(DECREMENT);

 /* Assignment operators */
"="    return(ASSN);
"+="   return(ADD_ASSN);
"-="   return(MINUS_ASSN);
"*="   return(MULTI_ASSN);
"/="   return(DIVIDE_ASSN);
"%="   return(MODULO_ASSN);
"&="   return(AND_ASSN);
"\|="  return(OR_ASSN);
"^="   return(XOR_ASSN);

 /* comparison operators */
"=="  return(EQUAL_COMP);
"!="  return(NOT_EQUAL_COMP);
"<"   return(LESS_THAN_COMP);
">"   return(GREATER_THAN_COMP);
"<="  return(LESS_THAN_EQUAL_COMP);
">="  return(GREATER_THAN_EQUAL_COMP);

 /* logical operators */
"&&"    return(LOGICAL_AND);
"\|\|"  return(LOGICAL_OR);
"!"     return(LOGICAL_NOT);

 /* bitwise operators */
"&"   return(AMP);
"\|"  return(BITWISE_OR);
"\^"  return(BITWISE_XOR);
"<<"  return(BITWISE_LSHIFT);
">>"  return(BITWISE_RSHIFT);
"~"   return(BITWISE_NOT);

 /* Literals: ints, floating-point, chars, strings */
(0)|(0x0)|([1-9]{digit}*)|(0x[1-9]|[a-fA-F])({digit}|[a-fA-F])*   {yylval = installNum(); return(LIT_NUM);    }
([1-9]{digit}*\.{digit}+)([Ee][+-]?[1-9]{digit}*)?                {yylval = installNum(); return(LIT_NUM);    }
\'[^\']?\'                                                        {yylval = installNum(); return(LIT_CHAR);   }
\"[^\"]*\"                                                        {yylval = installNum(); return(LIT_STRING); }


%%



/* ================================== */
/* User code */


/* function to install the lexeme of an ID,
   whose first char is pointed to by yytext,
   and whose length is yylang, into the symbol
   table and return a pointer to for yylval */
int* installID(){

    // add yytext lexeme to lexemes char array

    // add <yytext, pair<offset, tokenType> > to the LexemeTable

    // return offset, which becomes yylval (I think)

}


/* function to install the lexeme of a number,
   whose first char is pointed to by yytext,
   and whose length is yylang, into the symbol
   table and return a pointer to for yylval */
int* installNum(){

    // add yytext lexeme to lexemes char array


    // add <yytext, pair<offset, tokenType> > to the LexemeTable


    // return offset, which becomes yylval (I think)

}

