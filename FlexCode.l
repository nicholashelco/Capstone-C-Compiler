/* ================================== */
/* Definitions Section */


/* Code in %{ %} blocks are copied verbatim to output code */
%{

/* Header file generated by bison */
#include "TokenNames.tab.h"

%}

/* Regular Definitions here */
dlim    [ \t\n]
ws      {dlim}+
letter  [A-Za-z]
digit   [0-9]
id      (_|{letter})({letter}|{digit}|_)*



%%



 /* ================================== */
 // Rules Section */

 /* Consume whitespace */
{ws}+  { /* do nothing */ }

 /* Keywords */
if        return(IF_TOKEN);
else      return(ELSE_TOKEN);
for       return(FOR_TOKEN);
do        return(DO_TOKEN);
while     return(WHILE_TOKEN);
return    return(RETURN_TOKEN);
break     return(BREAK_TOKEN);
continue  return(CONTINUE_TOKEN);

short     return(SHORT_TYPE_TOKEN);
int       return(INT_TYPE_TOKEN);
long      return(LONG_TYPE_TOKEN);
unsigned  return(UNSIGNED_TYPE_TOKEN);
float     return(FLOAT_TYPE_TOKEN);
double    return(DOUBLE_TYPE_TOKEN);
char      return(CHAR_TYPE_TOKEN);
struct    return(STRUCT_TYPE_TOKEN);
enum      return(ENUM_TYPE_TOKEN);
union     return(UNION_TYPE_TOKEN);
void      return(VOID_TYPE_TOKEN);





 /* identifiers */
{id}  {yylval = installID(); return(ID_TOKEN); }

 /* parentheses, braces, brackets, punctuation */
"("   return(L_PAREN_TOKEN);
")"   return(R_PAREN_TOKEN);
"["   return(L_BRACKET_TOKEN);
"]"   return(R_BRACKET_TOKEN);
"{"   return(L_BRACE_TOKEN);
"}"   return(R_BRACE_TOKEN);
","   return(COMMA_TOKEN);
"."   return(DOT_TOKEN);
";"   return(SEMICOLON_TOKEN);
":"   return(COLON_TOKEN);
"?"   return(QUESTION_TOKEN);

 /* arithmetic operators */
"+"   return(PLUS_TOKEN);
"-"   return(MINUS_TOKEN);
"*"   return(ASTERISK_TOKEN);
"/"   return(DIVIDE_TOKEN);
"%"   return(MODULO_TOKEN);
"++"  return(INCREMENT_TOKEN);
"--"  return(DECREMENT_TOKEN);

 /* Assignment operators */
"="    return(ASSN_TOKEN);
"+="   return(ADD_ASSN_TOKEN);
"-="   return(MINUS_ASSN_TOKEN);
"*="   return(MULTI_ASSN_TOKEN);
"/="   return(DIVIDE_ASSN_TOKEN);
"%="   return(MODULO_ASSN_TOKEN);
"&="   return(AND_ASSN_TOKEN);
"\|="  return(OR_ASSN_TOKEN);
"^="   return(XOR_ASSN_TOKEN);

 /* comparison operators */
"=="  return(EQUAL_COMP_TOKEN);
"!="  return(NOT_EQUAL_COMP_TOKEN);
"<"   return(LESS_THAN_COMP_TOKEN);
">"   return(GREATER_THAN_COMP_TOKEN);
"<="  return(LESS_THAN_EQUAL_COMP_TOKEN);
">="  return(GREATER_THAN_EQUAL_COMP_TOKEN);

 /* logical operators */
"&&"    return(LOGICAL_AND_TOKEN);
"\|\|"  return(LOGICAL_OR_TOKEN);
"!"     return(LOGICAL_NOT_TOKEN);

 /* bitwise operators */
"&"   return(AMP_TOKEN);
"\|"  return(BITWISE_OR_TOKEN);
"\^"  return(BITWISE_XOR_TOKEN);
"<<"  return(BITWISE_LSHIFT_TOKEN);
">>"  return(BITWISE_RSHIFT_TOKEN);
"~"   return(BITWISE_NOT_TOKEN);

 /* Literals: ints, floating-point, chars, strings */
(0)|(0x0)|([1-9]{digit}*)|(0x[1-9]|[a-fA-F])({digit}|[a-fA-F])*   {yylval = installNum(); return(LIT_NUM_TOKEN);    }
([1-9]{digit}*\.{digit}+)([Ee][+-]?[1-9]{digit}*)?                {yylval = installNum(); return(LIT_NUM_TOKEN);    }
\'[^\']?\'                                                        {yylval = installNum(); return(LIT_CHAR_TOKEN);   }
\"[^\"]*\"                                                        {yylval = installNum(); return(LIT_STRING_TOKEN); }


%%



/* ================================== */
/* User code */


/* function to install the lexeme of an ID,
   whose first char is pointed to by yytext,
   and whose length is yylang, into the symbol
   table and return a pointer to for yylval */
int* installID(){

    // add yytext lexeme to lexemes char array

    // add <yytext, pair<offset, tokenType> > to the LexemeTable

    // return offset, which becomes yylval (I think)

}


/* function to install the lexeme of a number,
   whose first char is pointed to by yytext,
   and whose length is yylang, into the symbol
   table and return a pointer to for yylval */
int* installNum(){

    // add yytext lexeme to lexemes char array


    // add <yytext, pair<offset, tokenType> > to the LexemeTable


    // return offset, which becomes yylval (I think)

}

