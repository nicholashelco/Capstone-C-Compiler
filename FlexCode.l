/* ================================== */
/* Definitions Section */


/* Code in %{ %} blocks are copied verbatim to output code */
%{

/* Header file generated by bison */
#include "TokenNames.tab.h"

%}

/* Regular Definitions here */
dlim    [ \t\n]
ws      {dlim}+
letter  [A-Za-z]
digit   [0-9]
id      (_|{letter})({letter}|{digit}|_)*



%%



 /* ================================== */
 // Rules Section */

 /* Consume whitespace */
{ws}+  { /* do nothing */ }

 /* Keywords */
if        return(IF_TOK);
else      return(ELSE_TOK);
for       return(FOR_TOK);
do        return(DO_TOK);
while     return(WHILE_TOK);
return    return(RETURN_TOK);
break     return(BREAK_TOK);
continue  return(CONTINUE_TOK);

short     return(SHORT_TYPE_TOK);
int       return(INT_TYPE_TOK);
long      return(LONG_TYPE_TOK);
unsigned  return(UNSIGNED_TYPE_TOK);
float     return(FLOAT_TYPE_TOK);
double    return(DOUBLE_TYPE_TOK);
char      return(CHAR_TYPE_TOK);
struct    return(STRUCT_TYPE_TOK);
enum      return(ENUM_TYPE_TOK);
union     return(UNION_TYPE_TOK);
void      return(VOID_TYPE_TOK);





 /* identifiers */
{id}  {yylval = installID(); return(ID_TOKEN); }

 /* parentheses, braces, brackets, punctuation */
"("   return(L_PAREN_TOK);
")"   return(R_PAREN_TOK);
"["   return(L_BRACKET_TOK);
"]"   return(R_BRACKET_TOK);
"{"   return(L_BRACE_TOK);
"}"   return(R_BRACE_TOK);
","   return(COMMA_TOK);
"."   return(DOT_TOK);
";"   return(SEMICOLON_TOK);
":"   return(COLON_TOK);
"?"   return(QUESTION_TOK);

 /* arithmetic operators */
"+"   return(PLUS_TOK);
"-"   return(MINUS_TOK);
"*"   return(ASTERISK_TOK);
"/"   return(DIVIDE_TOK);
"%"   return(MODULO_TOK);
"++"  return(INCREMENT_TOK);
"--"  return(DECREMENT_TOK);

 /* Assignment operators */
"="    return(ASSN_TOK);
"+="   return(ADD_ASSN_TOK);
"-="   return(MINUS_ASSN_TOK);
"*="   return(MULTI_ASSN_TOK);
"/="   return(DIVIDE_ASSN_TOK);
"%="   return(MODULO_ASSN_TOK);
"&="   return(AND_ASSN_TOK);
"\|="  return(OR_ASSN_TOK);
"^="   return(XOR_ASSN_TOK);

 /* comparison operators */
"=="  return(EQUAL_COMP_TOK);
"!="  return(NOT_EQUAL_COMP_TOK);
"<"   return(LESS_THAN_COMP_TOK);
">"   return(GREATER_THAN_COMP_TOK);
"<="  return(LESS_THAN_EQUAL_COMP_TOK);
">="  return(GREATER_THAN_EQUAL_COMP_TOK);

 /* logical operators */
"&&"    return(LOGICAL_AND_TOK);
"\|\|"  return(LOGICAL_OR_TOK);
"!"     return(LOGICAL_NOT_TOK);

 /* bitwise operators */
"&"   return(AMP_TOK);
"\|"  return(BITWISE_OR_TOK);
"\^"  return(BITWISE_XOR_TOK);
"<<"  return(BITWISE_LSHIFT_TOK);
">>"  return(BITWISE_RSHIFT_TOK);
"~"   return(BITWISE_NOT_TOK);

 /* Literals: ints, floating-point, chars, strings */
(0)|(0x0)|([1-9]{digit}*)|(0x[1-9]|[a-fA-F])({digit}|[a-fA-F])*   {yylval = installNum(); return(LIT_NUM_TOK);    }
([1-9]{digit}*\.{digit}+)([Ee][+-]?[1-9]{digit}*)?                {yylval = installNum(); return(LIT_NUM_TOK);    }
\'[^\']?\'                                                        {yylval = installNum(); return(LIT_CHAR_TOK);   }
\"[^\"]*\"                                                        {yylval = installNum(); return(LIT_STRING_TOK); }


%%



/* ================================== */
/* User code */


/* function to install the lexeme of an ID,
   whose first char is pointed to by yytext,
   and whose length is yylang, into the symbol
   table and return a pointer to for yylval */
int* installID(){

    // add yytext lexeme to lexemes char array

    // add <yytext, pair<offset, tokenType> > to the LexemeTable

    // return offset, which becomes yylval (I think)

}


/* function to install the lexeme of a number,
   whose first char is pointed to by yytext,
   and whose length is yylang, into the symbol
   table and return a pointer to for yylval */
int* installNum(){

    // add yytext lexeme to lexemes char array


    // add <yytext, pair<offset, tokenType> > to the LexemeTable


    // return offset, which becomes yylval (I think)

}

